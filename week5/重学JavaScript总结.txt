【重学的原因】
自然掌握与系统学习之间存在不小的差距

【如何去定义一门语言？】
JavaScript的边界在哪里？

以中文为例
产生式：
句子->主语 谓语 宾语；
主语->代词|名词|短语；
代词->你|我|他
这个描述的过程，其实就是我们去定义中文语法的一个过程，把语言以不断细化的方式去定义
自然语言一般不是严禁的语言
计算机世界当中便有了产生式production，产生式的定义从设计上就证明了，计算机之所以能够准确、严禁地理解一门编程语言的理论基础。

进一步定义产生式
符号（Symbol）
	定义的语法结构名称
终结符（Terminal Symbol）与非终结符（Non-Terminal Symbol）
	终结符：不是由其他 符号定义的符号，也就是说，她不会出现在产生式左边
	其实Teminal Symbol翻译为终端符号可能更准确，因为它不是类似文件终结符这样的概念，应该是类似树的叶子结点的概念
	非终结符：由其他符号经过“与”、“或”等逻辑组成的符号
语言定义
	语言可以由一个非终结符和它的产生式来定义，比如说“中文”就是一个非终结符，它可以由一系列的句子来定义
语法树
	把一段具体的语言的文本，根据产生式以树形结构来表示出来。即我们可以把一段具体的语言根据产生式生成一个树形结构的非终结符，而这个树形结构就称之为语法树。但它跟抽象语法树AST又稍微有点区别。

语法和语义的区别
	语法：描述该语言的程序的正确形式
	语义：定义了程序的含义，即每个程序在运行时做什么

产生式的写法
BNF：巴科斯-诺尔范式（因为比较早期，宁愿语法上写的噪音多一点，也要用来保证严谨性和容易解析）
特点：
1、所有非终结符都是用尖括号(<>)抱起来的
2、用单竖线(|)来表示或的关系
3、用冒号冒号等于(::=)来表示定义
4、由于BNF中没有省略的表达，意味着有多个省略的情况下需要写多个或的分支，所以后面又有了对它进行改进的语法

可以采用递归的方式进行定义
<中文>::=<句子>|<中文><句子>
<句子>::=<主语><谓语><宾语>|<主语><谓语>
<主语>::=<代词>|<名词>|<名词性短语>
<代词>::="你"|"我"|"他"

EBNF:进阶版，因为语法的噪音比较小，所以在国际上现在属于比较流行的
特点：
1、不强制加尖括号
2、大括号代表可重复多次
3、中括号/方括号表示可以省略

中文::={句子}
句子::=主语 谓语 [宾语]
主语::=代词|名词|名词性短语
代词::="你"|"我"|"他"

其实还有ABNF之类的，大同小异

有了产生式的概念后，才能去体系化地理解JavaScript这么语言，而且很多语言的标准都没有严格按照BNF或EBNF的规范

JavaScript标准
引入了换行的机制来表达产生式的产生关系
冒号表示定义，冒号前面的是被定义的非终结符，冒号后面的是它的定义
通过断行表示或的关系，比如StatementListItem，它是语句或者声明
通过标黑来表示它是终结符，比如语句块Block，它肯定是花括号开头花括号结尾的，肯定是终结符
把产生式写成了一个类似函数的东西

网上很多资料把产生式用了BNF来替代，从严谨的角度上讲，肯定不是，比如JavaScript的这个标准，已经超出了任何的我们所谓的范式

【产生式具体在语言中的应用】
【词法和语法】计算机语言都有两份产生式，第一份叫词法产生式，第二份叫语法产生式
词法：正则文法（3型）
空白
换行
注释
Token（1个有效的词）
语法：上下文无关文法（2型）
语法树（去除一些不必要的信息后，会变成AST抽象语法树，用于代码结构的处理，可以对代码做一些翻译的工作，也可以对它做一些自动的review，在前端领域里面，babel就是做这样的工作的）

grammar语法

【JavaScript的词法和语法】
（一般语言的词法分析都是用的InputElement）
InputElement ::= WhiteSpace | LineTerminator | Comment | Token
翻译： 词法 ::= 空白 | 换行 | 注释 | 有效的词
WhiteSpace ::= " " | "　"
翻译：空白 ::== 半角空格 | 全角空格
（JavaScript规定了Unicode所有隶属于空白符的分类的字符都能算作空白）
知识点补充：
零宽度空格符 (zero-width space) \u200B : 用于较长单词的换行分隔
零宽度非断空格符 (zero width no-break space) \uFEFF : 用于阻止特定位置的换行分隔
零宽度连字符 (zero-width joiner) \u200D : 用于阿拉伯文与印度语系等文字中，使不会发生连字的字符间产生连字效果
零宽度断字符 (zero-width non-joiner) \u200C : 用于阿拉伯文，德文，印度语系等文字中，阻止会发生连字的字符间的连字效果
左至右符 (left-to-right mark) \u200E : 用于在混合文字方向的多种语言文本中（例：混合左至右书写的英语与右至左书写的希伯来语），规定排版文字书写方向为左至右
右至左符 (right-to-left mark) \u200F : 用于在混合文字方向的多种语言文本中，规定排版文字书写方向为右至左
LineTerminator ::= "\n" | "\r"
Comment ::= SingleLineComment | MultilineComment
SingleLineComment ::= "/""/"<any>*
MultilineComment ::= "/""*" <any>* "*""/" 错误
MultilineComment ::= "/""*" ([^*] | "*"[^/])* "*""/" 正确
Token ::= Literal | Keywords | Identifier | Punctuator

Literal ::= NumberLiteral | BooleanLiteral | StringLiteral | NullLiteral
Keywords ::= "if" | "else" | "function" | ......
Punctuator ::= "+" | "-" | "*" | "/" | "{" | "}" | ......
(JavaScript标准中的产生式中其实是把除号/单独从Punctuator中单独拎出来的，因为它跟正则表达式是有语法冲突的，同样，右大括号也是单独拎出来做特殊处理的，因为它跟字符串模板里面的美元$}也是冲突的)



Literal：直接量/自变量
Identifier：标识符
Punctuator：与Operator不同，Operator一定是用在表达式里的，代表操作符，花括号、小括号这些为了完成语法的字符则不属于Operator，但它属于Punctuator
Object也有literal，但是它是一个语法结构，词法里面没有，它是由Punctuator和Identifier这些东西组合出来的
Symbol没有literal，不管怎么写，都没法直接产生一个Symbol，但是你同样可以用语法上面的结构通过调用函数的方式构造Symbol
Undefined也是没有literal的，undefined在JavaScript里面并不是一个特殊的词，它只是一个普通的变量名，只不过是我们在global给它定义了一个undefined的这样的一个全局变量，这个全局变量在早期的js版本里还能改，例如可以把undefined改成true

1.3 1.5 "asd" 'asda' true false
JavaScript的变量类型

【实现语法分析的种子】
我们能接受的第一个token是什么？
program允许的第一个token是什么
也就是statementList能接受的第一个token或terminal symbol
需要把当前所有非终结符展开，这跟平时讲的闭包不一样
这个过程叫做求closure

【JavaScript的inputElement为什么有4个】
这4个的内容高度重复，区别的地方主要是DivPunctuator（除号/）、RightBracePunctuator（右大括号）、
正则表达式中没有除号，但多了一个正则表达式的直接量，两个斜杠中间的东西
由于js语言本身的复杂性，要想支持双斜杠中间写正则表达式的这种写法，它不完全符合我们经典编译原理理论的词法和语法的区分，要想知道一个斜杠是除号还是正则表达式的斜杠呢？就必须知道它在语法分析上进行到了一个什么阶段，所以实际上这些都是一种token

【广度优先搜索】
shift和push就能组成一对Enqueue和Dequeue，就是入队和出队，push是入队，shift是出队


【相关名词】
产生式： 在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句。

终结符： 最终在代码中出现的字符。

巴科斯诺尔范式：即巴科斯范式（英语：Backus Normal Form，缩写为 BNF）是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。

乔姆斯基谱系：是计算机科学中刻画形式文法表达能力的一个分类谱系，是由诺姆·乔姆斯基于 1956 年提出的。它包括四个层次：
0- 型文法（无限制文法或短语结构文法）包括所有的文法。
1- 型文法（上下文相关文法）生成上下文相关语言。
2- 型文法（上下文无关文法）生成上下文无关语言。
3- 型文法（正规文法）生成正则语言。

Brainfuck ：一种极小化的程序语言，它是由 Urban Müller 在 1993 年创造的。由于 fuck 在英语中是脏话，这种语言有时被称为 Brainfck 或 Brainf**，或被简称为 BF。

【关键词翻译】
statement 语句
expression 表达式
js代码绝大部分是靠statement和expressionStatement这两个分层来解决的主体结构


【构建语法树】
前面的课程中，我们已经把对JavaScript做了词法分析，能够把无意义的字符变成有意义的token和空白等代码中的基础元素
本节课继续根据这些代码中的基础元素形成一棵更复杂的树状的语法结构，称为语法树，再对这颗语法树进行精简的处理之后，可以得到抽象语法树AST
运用编译原理的基础知识来完成语法树的构造
编程语言的语法树的构造，比声明语言要复杂得多，必须要运用到编译原理的一些技巧，以应用为主，这里已经进行了大幅度的简化

课程中必须处理的:
var a = 1;

a() + 10 * x;

if(a) {

} else {

}

while(1) {

}


function foo(x, y) {
	return abc;
}

前面的课程中已经学习了如何使用abnf去描述JavaScript的语法结构
本节课将使用JavaScript代码把abnf所描述的语法结构变成一个真正意义上的语法s
形成能够解析出语法树的代码
在社区里看到的更多的语法分析是用的ll的风格，这个叫做一种parser combinator，我们代码里面的内容基本跟语法描述的BNF的结构是一致的，我们的课程需要采取另外一种语法分析的算法，叫lr
纯粹的BNF结构不太好靠代码去理解，所以还是会写成js的json格式的形式，比如或用一种结构，与用一种结构

Additive 加法
Multiplicative 乘法
Unary 一元运算
primary 基本的
Literal 直接量
Identifier 标识符 变量


【相关练习】
1. 允许小数的四则运算产生式 
思考：小数点前头和后头都必须有1位至多位数字；小数点后面的尾数可以是0开头
<四则预算表达式>::=<加法算式>
<加法算式>::=(<加法算式> ("+"|"-") <乘法算式>) | <乘法算式>
<乘法算式>::=(<乘法算式> ("*"|"/") <小数>) | <小数>
<小数>::=(<整数>.<尾数>) | <整数>
<整数>::=("0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9")|("1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"){"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"}
<尾数>::=("0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"){"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"}

2. 允许括号的四则运算产生式
思考：括号运算符的优先级最高
<四则预算表达式>::=<加法算式>
<加法算式>::=(<加法算式> ("+"|"-") <乘法算式>) | <乘法算式>
<乘法算式>::=(<乘法算式> ("*"|"/") <括号算式>) | <括号算式>
<括号算式>::="(" <加法算式> ")" | <整数>
<整数>::=("0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9")|("1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"){"0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9"}
