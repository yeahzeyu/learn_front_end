【概述】从开局只有一个URL，把它变成了一段HTML代码，再从HTML代码又把它变成了一棵DOM树，又把这棵什么都没有的DOM树加上了CSS的属性，再把这些CSS属性最终计算出来它的每一个元素的位置，直到最后我们在一张图片上把网页的内容给它画了出来，这个过程已经是一个浏览器从一个URL到最终呈现的一个最基础的答案了。通过开发toy browser，我已经对浏览器的工作原理已经有了一个深入的理解和感性的认知了。

【重点回顾】
1）服务端，准备nodeJs环境，搭建简易服务端，用于在客户端http协议请求时返回head、body等报文
2）客户端，
    1、实现http协议请求url并获取response中的状态码，消息体等的逻辑，获取html，利用状态机完成html parser，解析html成一棵原始的DOM树。
	2、使用npm包CSS parser实现CSS解析，并将其匹配到原始DOM树上，得到一棵带CSS属性的DOM树
	3、对CSS属性进行计算，理解并实现了基础的flex布局，重点概念有flex元素、主轴、交叉轴以及两个轴上的六个重要位置及尺寸参数。
	4、使用npm报images实现将CSS属性计算的DOM树绘制到一张图片并输出，具体过程是将绘制在一个viewport上进行，然后再讲viewport保存成图片。
	5、从实现绘制单个元素开始，递归掉用绘制函数，从父元素开始绘制，再逐级绘制其下的子孙元素
	6、toy browser离真正的浏览器还差很多，甚至我们也没有去做文字渲染，也没有做边框、实现layout的offset逻辑，实际浏览器中，文字绘制是难点，需要依赖字体库，还会对一些图层做compositing，我们这里都忽略了，这门课程主要是用来让非浏览器开发的前端人员理解整个浏览器的基础工作原理的。
3）编程概念
	1、状态机：每一个状态都是一个机器，每个机器都知道下一个状态，分为Moore型（每个机器都有确定的下一个状态）和Mealy型（每个机器根据输入决定下一个状态）
	2、KMP算法：主要是通过消除主串指针的回溯来提高匹配的额效率。用于加速匹配的信息：对于每模式串 t 的每个元素 t j，都存在一个实数 k ，使得模式串 t 开头的 k 个字符（t 0 t 1…t k-1）依次与 t j 前面的 k（t j-k t j-k+1…t j-1，这里第一个字符 t j-k 最多从 t 1 开始，所以 k < j）个字符相同。如果这样的 k 有多个，则取最大的一个。模式串 t 中每个位置 j 的字符都有这种信息，采用 next 数组表示，即 next[ j ]=MAX{ k }。